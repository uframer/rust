# 基本类型

Rust语言中有一些类型被称作*基本类型*，它们内置于语言之中。Rust的标准库以这些基本类型为基础，提供了很多有用的类型。

# 布尔类型

Rust的内建布尔类型叫`bool`。它有两个可选值，`true`和`false`：

```rust
let x = true;

let y: bool = false;
```

布尔类型经常用于[`if`表达式的条件][if]中。

[if]: if.html

你可以在[标准库文档][bool]中找到更多关于`bool`的信息。

[bool]: ../std/primitive.bool.html

# `char`

`char`类型代表一个Unicode标量值。你可以用单引号（`'`）书写`char`类型的文字量：

```rust
let x = 'x';
let two_hearts = '💕';
```

不同于其他语言，这意味着Rust的`char`类型不是一个字节，而是4个字节。

你可以在[标准库的`char`文档][char]中找到更多信息。

[char]: ../std/primitive.char.html

# 数值类型

Rust的数值类型可以按照不同的标准划分为不同的类别：有符号和无符号、定长和变长、浮点数和整数。

如果Rust无法推断出一个数值文字量的类型，那么它的默认类型为：

```rust
let x = 42; // `x`的类型是`i32`。

let y = 1.0; // `y`的类型是`f64`。
```

下面列出所有的数值类型，点击链接可以查看它们的标准库文档：

* [i8](../std/primitive.i8.html)
* [i16](../std/primitive.i16.html)
* [i32](../std/primitive.i32.html)
* [i64](../std/primitive.i64.html)
* [u8](../std/primitive.u8.html)
* [u16](../std/primitive.u16.html)
* [u32](../std/primitive.u32.html)
* [u64](../std/primitive.u64.html)
* [isize](../std/primitive.isize.html)
* [usize](../std/primitive.usize.html)
* [f32](../std/primitive.f32.html)
* [f64](../std/primitive.f64.html)

接下来我们按照不同的分类方式来介绍它们：

## 有符号数和无符号数

整数类型分为两种：有符号整数和无符号整数。无符号类型使用`u`做前缀，有符号类型使用`i`做前缀。

## 定长类型

定长类型占据的位数是确定的，不随着系统平台变化。Rust支持的位数包括`8`、`16`、`32`和`64`。例如，`u32`是无符号的32位整数，`i64`是有符号的64位整数。

## 变长类型

Rust还提供了一些大小随着底层机器架构变化的类型。由于它们的大小足够表示底层机器架构上任意集合的大小，所以它们的名字里有‘size’字样。它们按照有没有符号分为两种：`isize`和`usize`。

## 浮点类型

Rust支持两种类型的浮点数：`f32`和`f64`。它们对应于IEEE-754的单精度浮点数和双精度浮点数。

# 数组

同很多语言一样，Rust有很多表示数据序列的列表类型，其中最基本的*数组*，数组长度固定，元素具有相同的类型。默认情况下，数组是不可变的。

```rust
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
```

数组的类型是`[T; N]`。我们会在[泛型][generics]介绍`T`这种写法。`N`是一个编译时常量，表示数组的长度。

如果想用同样的值初始化所有的数组元素，可以使用下面的写法：

```rust
// 用0初始化所有20个元素
let a = [0; 20]; // a: [i32; 20]
```

可以通过`len()`方法获取数组的长度（元素个数），例如数组`a`的长度是`a.len()`：

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```

你可以使用*下标*访问数组中的元素：

```rust
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("The second name is: {}", names[1]);
```

同大多数语言一样，数组的下标从0开始。上面的例子会打印出`The second name is: Brian`。如果你的小标超出了数组的范范围，就会在运行时触发便捷检查错误。数组越界是很多语言中的常见错误。

数组的详细文档在标准库文档的[`array`][array]部分。

[array]: ../std/primitive.array.html

# 切片

切片‘slice’是对另一个数据结构的引用（或者说是*视图*）。它可以高效地访问访问数组中的某一部分，无需引入拷贝动作。例如，对于已经读入内存中的文件，你可能只想引用其中的一行。由于切片这种引用的天然属性，你不能创建独立的切片，它必须从一个已有的变量绑定来创建。切片的长度是固定的，可以是不可变的也可以是可变的。

在内部，切片由一个指向数据开始位置的指针和一个长度组成。

## 切片语法

你可以使用`&`和`[]`符号的组合从很多类型创建切片。`&`符号表示切片同[引用][references]有相似之处，我们后面会解释这一点。`[]`符号里是一个区间，你用它来定义切片的起止位置（从而间接定义了长度）：

```rust
let a = [0, 1, 2, 3, 4];
let complete = &a[..]; // 包含`a`全部元素的切片。
let middle = &a[1..4]; // 一个`a`的切片：里面的元素包括`1`、`2`和`3`。
```

切片的类型是`&[T]`。我们会在[泛型][generics]介绍`T`这种写法。

[generics]: generics.html

切片的详细文档可以在[标准库的文档][slice]中找到。

[slice]: ../std/primitive.slice.html

# `str`

Rust的`str`类型是最基础的字符串类型。由于它是一种[未定大小类型][dst]（每条字符串的长度取决于它的内容，所以`str`类型本身没有固定的大小），所以并不是一种是否好用的类型，但是它的引用`&str`的用途有很多。我们会在讲到[Strings][strings]和[引用][references]时更详细的介绍它。

[dst]: unsized-types.html
[strings]: strings.html
[references]: references-and-borrowing.html

切片的详细文档可以在标准库的文档的[`str`][str]部分找到。

[str]: ../std/primitive.str.html

# 元组

元素是固定长度的有序列表。例如：

```rust
let x = (1, "hello");
```

元组使用圆括号定义，其中的元素使用逗号分隔。如果我们标出上面元素的类型的话，会是这样：

```rust
let x: (i32, &str) = (1, "hello");
```

细心地读者可能已经注意到，元组是异构的容器：`x`的成员是一个`i32`和一个`&str`。

在系统编程语言中，字符串的处理要比其他语言麻烦一些。从现在开始，请将`&str`读成*字符串切片*，我们很快就会讲到它。

你可以用一个元组给另一个元组赋值。，前提是它们具有相同的[元素个数][arity]，并且它们的类型要相同，这意味着它们的对应元素的类型要相同。

[arity]: glossary.html#arity

```rust
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
```

你可以使用被称作*析构let*的语法来访问元素的成员。看一个例子：

```rust
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
```

还记得我们[之前][let]提到过`let`语句的左边是模式匹配的事情吗？现在我们就看到一种匹配的形式。如果左侧的列表能够同右侧的内容相匹配，我们就可以同时给多个变量赋值。在这个例子中，`let`将右侧的元组打散，然后将元组的元素分别绑定给左边的三个变量。

[let]: variable-bindings.html

这个模式非常强大，我们后面会经常见到它。

如果你的元组中只有一个元素，那么请注意添加一个看起来多余的逗号，因为只有依靠它，编译器才不会把它同一个包在圆括号中的值相混淆：

```rust
(0,); // 这是只有一个元素0的元组。
(0);  // 这是包在圆括号里的一个0.
```

## 元组索引

你也可以通过索引语法访问元组的成员：

```rust
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);
```

同数组的索引一样，元组的索引也从0开始，不过不同于数组使用的方括号，元组的索引使用一个句号`.`来指定。

可以在[标准库文档的`tuple`部分][tuple]看到更为详细的介绍。

[tuple]: ../std/primitive.tuple.html

# 函数

函数也有类型！它们的类型看起来像这样：

```rust
fn foo(x: i32) -> i32 { x }

let x: fn(i32) -> i32 = foo;
```

在这个例子中，`x`是一个*函数指针*，它指向一个以`i32`做参数并返回`i32`的函数。
